# .cursorrules

# This rule set defines guidelines for the Event Parking App, ensuring modularity, maintainability, and scalability.

# ------------------------------------------------------------------------------

# Author

# ------------------------------------------------------------------------------

author:
name: "Alec Zaitz"
email: "[aleczaitz@gmail.com](mailto\:aleczaitz@gmail.com)"

# ------------------------------------------------------------------------------

# Project/Architecture Requirements

# ------------------------------------------------------------------------------

name: Event Parking App
description: "A web app that allows users to rent out their driveways for event parking."
architecture\_style:
primary: Modular Monolith
language: TypeScript
framework: React (Frontend), Firebase (Backend)
database: Firestore (NoSQL)
patterns:
\- Modular Design
\- Repository Pattern
\- Context API for global state management
\- Custom Hooks for reusable logic
\- Single Responsibility Principle (SRP) in all components

scale\_requirements:
data\_volume: Medium (Scalable with Firestore indexing)
processing\_capacity: Efficient querying using Firestore indexes
storage\_requirements: Structured JSON storage in Firestore

cloud\_integration:
provider: Firebase
frameworks: []
infrastructure\_as\_code: []

# ------------------------------------------------------------------------------

# Core Architectural Principles

# ------------------------------------------------------------------------------

architectural\_principles:
SOLID\_principles:
\- Single Responsibility Principle (SRP): Each component and function should have one responsibility.
\- Open-Closed Principle (OCP): Components should be open for extension but closed for modification.
\- Liskov Substitution Principle (LSP): Subtypes must be substitutable for their base types without breaking functionality.
\- Interface Segregation Principle (ISP): Avoid large interfaces; create smaller, more specific ones.
\- Dependency Inversion Principle (DIP): High-level modules should not depend on low-level modules but rather on abstractions.
separation\_of\_concerns:
\- Authentication (User login, Firebase Auth)
\- Event Listings (Fetching and displaying events from Firestore)
\- Driveway Management (Renting & Listing driveways)
\- Payment Processing (Stripe integration)
\- Messaging System (User-to-user communication)
modular\_design:
\- Components should be **reusable and independent**
\- **Separate UI from business logic** using services and hooks
\- **Maintain clear service boundaries** between UI, data fetching, and business logic
\- **All source files must include a comment at the top with their relative path from project root**

# ------------------------------------------------------------------------------

# File Structure & Best Practices

# ------------------------------------------------------------------------------

file\_structure:

- src/
  - components/        # Reusable UI components
  - pages/             # Individual pages (Navigation Routes)
  - hooks/             # Custom hooks (useAuth, useListings, useEvents)
  - context/           # Global state management
  - services/          # Firebase interactions (API layer)
  - styles/            # Global styles
  - utils/             # Utility functions
  - App.tsx            # Main App Component

# ------------------------------------------------------------------------------

# State Management

# ------------------------------------------------------------------------------

state\_management:
pattern: "Context API + Custom Hooks"
principles:
\- Use **Context API** for global states like authentication
\- Use **custom hooks** (useEvents, useDriveways) to encapsulate logic
\- Avoid prop drilling by using React Context where appropriate
\- Keep state **immutable** to avoid unintended side effects
implementation:
required\_hooks:
\- "src/hooks/useAuth.ts"
\- "src/hooks/useEvents.ts"
\- "src/hooks/useDriveways.ts"
anti\_patterns:
\- "Storing large application states in component state instead of Context"
\- "Passing excessive props down multiple component layers"
\- "Recreating stateful objects unnecessarily"

# ------------------------------------------------------------------------------

# Authentication

# ------------------------------------------------------------------------------

authentication:
provider: Firebase Auth
principles:
\- Users can view events and driveways without signing in
\- **Signing in is required** to book or register a driveway
\- Store **user session state globally** using Context API
required\_files:
\- "src/hooks/useAuth.ts"
\- "src/context/AuthContext.tsx"
anti\_patterns:
\- "Storing sensitive data in localStorage"
\- "Allowing non-authenticated users to make bookings"

# ------------------------------------------------------------------------------

# Navigation & UI Components

# ------------------------------------------------------------------------------

ui\_components:

- NavigationBar (Persistent navigation across pages)
- EventSearchPage (Landing page with search bar)
- UpcomingEventsPage (Lists available events)
- DrivewaySelectPage (Lists available driveways and maps)
- BookingConfirmationPage (Checkout and Stripe integration)
- MyListingsPage (List of user’s driveways)
- MyBookingsPage (List of user’s bookings)
- MessagesPage (User-to-user communication)
- AccountSettingsPage (User profile settings)
- AdminPanel (Manage events and driveways for admin users)
- RegisterDrivewayPage (Form for listing a driveway)
- RegisterAnEventPage (Form for registering a new event)

# ------------------------------------------------------------------------------

# Firebase Firestore Guidelines

# ------------------------------------------------------------------------------

database:
structure:
\- /events
\- eventId
\- title
\- location
\- date
\- driveways: [drivewayId]
\- /driveways
\- drivewayId
\- owner
\- address
\- price
\- eventId
best\_practices:
\- Use **indexed queries** to optimize performance
\- Keep **data normalized** (avoid redundant storage)
\- Use **Firestore rules** for security (role-based access control)
anti\_patterns:
\- "Storing entire event details inside each driveway"
\- "Not using Firestore indexes for searching"
\- "Making unoptimized queries that fetch unnecessary data"

# ------------------------------------------------------------------------------

# Payments (Stripe Integration)

# ------------------------------------------------------------------------------

payment\_processing:
provider: Stripe
principles:
\- Payments should be **secure and follow Stripe best practices**
\- Use **serverless functions** (Firebase Functions) for processing transactions
\- Store **transaction history** in Firestore
anti\_patterns:
\- "Handling payments directly in frontend without server validation"
\- "Not securely storing payment-related metadata"

# ------------------------------------------------------------------------------

# Deployment & Hosting

# ------------------------------------------------------------------------------

deployment:
provider: Firebase Hosting
best\_practices:
\- Use **GitHub Actions** for automated deployments
\- Ensure **environment variables are securely stored**
\- **Optimize assets** (images, scripts) before deployment
anti\_patterns:
\- "Committing Firebase credentials to source code"
\- "Deploying untested code to production"

# ------------------------------------------------------------------------------

# Testing

# ------------------------------------------------------------------------------

testing:
framework: Jest + React Testing Library
test\_types:
\- Unit
\- Integration
best\_practices:
\- Maintain **high test coverage** for critical features
\- Ensure **GitHub Actions runs tests on all PRs**
anti\_patterns:
\- "Skipping tests for major features"
\- "Not writing tests for API interactions"

# ------------------------------------------------------------------------------

# DO NOT

# ------------------------------------------------------------------------------

prohibited:

- Store credentials in code
- Skip error handling
- Hardcode Firebase configurations
- Use `console.log()` instead of proper logging
- Commit node\_modules directory to version control
- Skip authentication checks
- Use `any` type in TypeScript without justification
- Directly mutate Firestore documents without validation
- Deploy without security rules in Firestore
- Adding a new file without making sure it doesn't already exist by thoroughly searching the codebase
